/*
Boost Software License - Version 1.0 - August 17th, 2003
 * Modified by Victor Rouquette - January 2017

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */

/* 
 * File:   FCore.cpp
 * Author: guillem
 *
 * Created on 27 janvier 2017, 11:47
 */

#include "Core/FCore.hpp"

FCore::FCore(){

}

FCore::FCore(   std::shared_ptr< FQueue< std::shared_ptr< FMessages > > > _pop_queue_parser, 
                std::shared_ptr< FQueue< std::shared_ptr< FMessages > > > _push_queue_parser,
                std::shared_ptr< FQueue< std::shared_ptr< FMessages > > > _pop_queue_render,
                std::shared_ptr< FQueue< std::shared_ptr< FMessages > > > _push_queue_render
             ):
              _m_pop_queue_parser(_pop_queue_parser),
              _m_push_queue_parser(_push_queue_parser),
              _m_pop_queue_render(_pop_queue_render),
              _m_push_queue_render(_push_queue_render),
              awake(true)
              {

              }

FCore::~FCore(){

}






/*
 * TIMESTAMPS MANAGER
 * THIS THREAD WILL MANAGE THE TIMESTAMPS KEPT IN MEMORY
 */
void FCore::thr_timestamps_manager(){
    std::cout << "in thr_timestamps_manager" << std::endl;
    while(1){
    	/*
  		 *
  		 * COMPUTING LOOP
  		 *
  		 */
        if(!m_render_timestamps.empty()){
   	   	   /*
         	* 
         	* MESSAGE FROM RENDER
		 	*
		 	*/
            std::shared_ptr<FMessages> msg_render =  *(m_render_timestamps.try_pop()) ;
            
            auto received = *( std::static_pointer_cast<patternStruct>(msg_render->getContent() ) );
			std::cout << "CORE >>> TIMESTAMPS RECEIVED FROM RENDER in container : " << received.contId << ", of pattern : " << received.id << ", beginning at : " << received.tBegin << std::endl;

            float beginTime = received.tBegin;
            float endTime = received.tEnd;

			if( m_containers.key_exists( received.contId )){
   			   /* 
            	* 
            	* THERE ARE TIMESTAMPS IN THE SAME CONTAINER AS THE DEMANDED ONES IN MEMORY 
				*
            	*/
	            if( m_containers.at( received.contId )->contains( received ) ){
	            	/*
					 *
					 * TIMESTAMPS IN THE SAME CONTAINER AS DEMANDED TIMESTAMPS ARE IN MEMORY
					 *
	            	 */
	                if(isContainerFull(received.contId, beginTime, endTime)){
	                   /*
					 	*
					 	* ALL DEMANDED TIMESTAMPS ARE IN MEMORY
					 	*
	            	    */
	                	std::cout << "CORE >>> ALL DEMANDED TIMESTAMPS ARE IN MEMORY" << std::endl;
	                    patternStruct pattern_send = {received.id, received.contId, beginTime, endTime};
	                    std::shared_ptr<void> content_send = std::static_pointer_cast<void>( std::make_shared<patternStruct>(pattern_send) );
	                    FMessages msg_send(TIMESTAMP, content_send); 
	                    _m_push_queue_render->push( std::make_shared< FMessages >(msg_send) );

	                }else{
	                   /*
					 	*
					 	* SOME OF THE DEMANDED TIMESTAMPS ARE IN MEMORY
					 	*
	            	    */
	                    float endTimeLoaded = getContainerContent( received.contId, beginTime );
	                    patternStruct pattern_send = {received.id, received.contId, beginTime, endTimeLoaded};
	                    std::shared_ptr<void> content_send = std::static_pointer_cast<void>( std::make_shared<patternStruct>(pattern_send) );
	                    FMessages msg_send(TIMESTAMP, content_send); 
	                    _m_push_queue_render->push( std::make_shared< FMessages >(msg_send) );              
	                } /* else if(isContainerFull(received.contId, beginTime, endTime)) */

	            }else{
	               /* 
            	 	* 
            	 	* ALL THE DEMANDED TIMESTAMPS ARE NOT IN MEMORY 
				 	*
            	 	*/
					std::cout << "CORE >>> NONE OF THE DEMANDED TIMESTAMPS ARE IN MEMORY" << std::endl;
	                _m_push_queue_parser->push( msg_render );
	                std::cout << "CORE >>> send timestamps demand to parser" << std::endl;

	            } /* else if( m_containers.at( received.contId )->contains( received ) ) */
			
			}/* if( m_containers.key_exists( received.contId )) */

        } /* if(!m_render_timestamps.empty()) */

        
        if(!m_parser_timestamps.empty()){
   	       /*
         	* 
         	* MESSAGE FROM RENDER
		 	*
		 	*/
            std::shared_ptr<FMessages> msg_parser = *(m_parser_timestamps.try_pop() );
            std::cout << "COUNT timestamps from parser" << msg_parser.use_count() << std::endl;

            auto received = *( std::static_pointer_cast<patternStruct>(msg_parser->getContent() ) );
            std::cout << "TIMESTAMPS RECEIVED FROM PARSER in container : " << received.contId << ", of pattern : " << received.id << ", beginning at : " << received.tBegin << std::endl;

            m_containers.at( received.contId )->add_pattern( received );

            float beginTime = received.tBegin;
            float endTime = received.tEnd;

            if(isContainerFull(received.contId, beginTime, endTime)){
                patternStruct pattern_send = {received.id, received.contId, beginTime, endTime};
                std::shared_ptr<void> content_send = std::static_pointer_cast<void>( std::make_shared<patternStruct>(pattern_send) );
                FMessages msg_send(TIMESTAMP, content_send); 
                _m_push_queue_render->push( std::make_shared< FMessages >(msg_send) );

            }else{
                float endTimeLoaded = getContainerContent( received.contId, beginTime );
                patternStruct pattern_send = {received.id, received.contId, beginTime, endTimeLoaded};
                std::shared_ptr<void> content_send = std::static_pointer_cast<void>( std::make_shared<patternStruct>(pattern_send) );
                FMessages msg_send(TIMESTAMP, content_send); 
                _m_push_queue_render->push( std::make_shared< FMessages >(msg_send) );

            } /* else if(isContainerFull(received.contId, beginTime, endTime)) */

        } /* if(!m_parser_timestamps.empty()) */

    } /* while(1) */

}/* void FCore::thr_timestamps_manager() */






/*
 * OCCURRENCES MANAGER
 * THIS THREAD WILL MANAGE THE OCCURRENCE KEPT IN MEMORY
 */
void FCore::thr_occurrences_manager(){
    std::cout << "in thr_occurrences_manager" << std::endl;
    while(1){
  		/*
  		 *
  		 * COMPUTING LOOP
  		 *
  		 */
        if(!m_render_occurrences.empty()){
    	   /*
         	* 
         	* MESSAGE FROM RENDER
		 	*
		 	*/
            std::shared_ptr<FMessages> msg_render = *(m_render_occurrences.try_pop());

            auto received = *( std::static_pointer_cast< std::pair<int, int> >(msg_render->getContent() ) );
            std::cout << "CORE >>> OCCURRENCE RECEIVED FROM RENDER nÂ° " << received.first << ":" << received.second << std::endl;

            if( m_occurrences.key_exists(received.first)){
   			   /* 
            	* 
            	* THERE ARE OCCURRENCES FROM THE SAME PATTERN AS THE DEMANDED ONE IN MEMORY 
				*
            	*/
            	if( contains_occurrence(received.first, received.second) ){
            	   /* 
            	 	* 
            	 	* THE DEMANDED OCCURRENCE IS IN MEMORY 
				 	*
            	    */
					std::cout << "CORE >>> IS IN MEMORY" << std::endl;
                	std::shared_ptr<FOccurrence> occurrence_send = find_occurrence(received.first, received.second );
                	auto content_send = std::static_pointer_cast<void>( occurrence_send );
                	FMessages msg_send(OCCURRENCE, content_send);
                	_m_push_queue_render->push( std::make_shared<FMessages>(msg_send) );
                	std::cout << "CORE >>> send occurrence " << occurrence_send->getPatternId() << ":" << occurrence_send->getId() << " to render from memory" << std::endl;
           
                }else{
                   /* 
            	 	* 
            	 	* THE DEMANDED OCCURRENCE IS NOT IN MEMORY 
				 	*
            	 	*/
					std::cout << "CORE >>> OCCURRENCE IS NOT IN MEMORY 1" << std::endl;            	
                	_m_push_queue_parser->push( msg_render );
                	std::cout << "CORE >>> send occurrence demand to parser" << std::endl;	
     
                } /* else if( contains_occurrence(received.first, received.second) ) */
      
            }else{ 
            	/* 
            	 * 
            	 * THE DEMANDED OCCURRENCE IS NOT IN MEMORY 
				 *
            	 */
				std::cout << "CORE >>> OCCURRENCE IS NOT IN MEMORY 2" << std::endl;            	
                _m_push_queue_parser->push( msg_render );
                std::cout << "CORE >>> send occurrence demand to parser" << std::endl;
     
            } /* else if( m_occurrences.key_exists(received.first)) */



        	/*
 			 * BEGIN
 			 * DEBUGGING MESSAGE
 			 * BEGIN
        	 */
	        std::cout << "CORE >>> OCCURRENCE Size : " << m_occurrences.size() << std::endl;
	        if(m_occurrences.size() > 0){
	         	for(auto it = m_occurrences.getMap().begin(); it != m_occurrences.getMap().end(); ++it){
	          		std::cout << "CORE >>> M_OCCURRENCES PATTERN KEY : " << it->first << std::endl;
	          		std::cout << "                              Size : " << (it->second)->size() << std::endl;
	          		std::cout << "                            Values : ";
	          		for(auto it2 = (it->second)->begin(); it2 != (it->second)->end(); ++it2 ){
	          	 		std::cout << (*it2)->getId() << " "; 
	          		}
	          			std::cout << std::endl;
	         	}
	        }
        	/*
 			 * END
 			 * DEBUGGING MESSAGE
 			 * END
        	 */
    
        } /* if(!m_render_occurrences.empty()) */
        
        if(!m_parser_occurrences.empty()){
			/*
			 *
	         * MESSAGE FROM PARSER
			 *
			 */
            std::shared_ptr<FMessages> msg_parser = *(m_parser_occurrences.try_pop() );

            auto received = std::static_pointer_cast< FOccurrence >(msg_parser->getContent() ) ;
            std::cout << "CORE >>> OCCURRENCE RECEIVED FROM PARSER nÂ°" << received->getPatternId() << ":" << received->getId() << std::endl;

            std::pair<int, int> key = std::make_pair( received->getPatternId(), received->getId() );

            if( m_occurrences.key_exists(key.first)){
            	/* 
            	 * 
            	 * THERE ARE STILL OCCURRENCES IN MEMORY FROM THE SAME PATTERN AS THE RECEIVED'S ONE 
				 *
            	 */
            	m_occurrences.at(key.first)->push_back( received );
   
            }else{
            	/* 
            	 * 
            	 * THERE IS NO OTHER OCCURRENCES IN MEMORY FROM THE SAME PATTERN AS THE RECEIVED'S ONE
				 *
            	 */
            	auto pair_to_insert = std::make_pair(key.first, std::make_shared< std::vector< std::shared_ptr<FOccurrence> > >() );
            	m_occurrences.insert( pair_to_insert ); 
            	m_occurrences.at(key.first)->push_back( received );
  
            } /* if( m_occurrences.key_exists(key.first)) */

            std::cout << "CORE >>> send occurrence " << received->getPatternId() << ":" << received->getId() << " to render" << std::endl;
            _m_push_queue_render->push(msg_parser);
            

            if(!m_occurrences.empty()){
	            /*
				 *
				 * SORTING OCCURRENCES FOR EACH PATTERN
				 *
	             */
	        	for(auto it = m_occurrences.getMap().begin(); it != m_occurrences.getMap().end(); ++it){
					std::sort(it->second->begin(), it->second->end(), []( std::shared_ptr<FOccurrence> occ1 , std::shared_ptr<FOccurrence> occ2 ){ return (occ1->getId() < occ2->getId() ); });    		
        		}   	
  
        	} /* if(!m_occurrences.empty()) */

        	/*
 			 * BEGIN
 			 * DEBUGGING MESSAGE
 			 * BEGIN
        	 */
	        std::cout << "CORE >>> OCCURRENCE Size : " << m_occurrences.size() << std::endl;
	        if(m_occurrences.size() > 0){
	         	for(auto it = m_occurrences.getMap().begin(); it != m_occurrences.getMap().end(); ++it){
	          		std::cout << "CORE >>> M_OCCURRENCES PATTERN KEY : " << it->first << std::endl;
	          		std::cout << "                              Size : " << (it->second)->size() << std::endl;
	          		std::cout << "                            Values : ";
	          		for(auto it2 = (it->second)->begin(); it2 != (it->second)->end(); ++it2 ){
	          	 		std::cout << (*it2)->getId() << " "; 
	          		}
	          			std::cout << std::endl;
	         	}
	        }
        	/*
 			 * END
 			 * DEBUGGING MESSAGE
 			 * END
        	 */

        } /* if(!m_parser_occurrences.empty()) */

    } /* while(1) */

} /* void FCore::thr_occurrences_manager() */






/*
 * MESSAGE HANDLER PARSER
 * THIS THREAD TAKE MESSAGES FROM THE PARSER AND CHECK WHAT IT MUST WITH THEM
 */
void FCore::thr_messages_handler_parser(){
    std::cout << "in message_handler_parser" << std::endl;
    while(1){
        std::shared_ptr<FMessages> msg = *(_m_pop_queue_parser->wait_and_pop());
        if( msg.use_count() != 0 && msg != NULL){
            switch(msg->getHeader()){
                case(START):
                {
                    std::cout << "CORE >>> START MESSAGE RECEIVED FROM PARSER" << std::endl;
                    break;
                }
                case(INITDONE):
                {
                    std::cout << "CORE >>> INITDONE MESSAGE RECEIVED FROM PARSER" << std::endl;
                    break;
                }
                case(CONTAINER):
                {
                    std::cout << "CORE >>> CONTAINER MESSAGE RECEIVED FROM PARSER" << std::endl;
                    std::shared_ptr<FContainer> received = std::static_pointer_cast<FContainer>(msg->getContent());
                    std::pair<int, std::shared_ptr<FContainer> > my_pair(received->getId() , received);
                    m_containers.insert( my_pair );
                    std::cout << "M_CONTAINERS SIZE IS NOW : " << m_containers.size() << std::endl;
                    std::cout << "M_CONTAINERS IS NOW : ";
                    for(unsigned int i = 0; i < m_containers.size(); ++i){
                    	std::cout << " " << m_containers[i]->getId();
                    }
                    std::cout << std::endl;
                    break;
                }
                case(PATTERN):
                {
                    std::cout << "CORE >>> PATTERN MESSAGE RECEIVED FROM PARSER" << std::endl;
                    std::shared_ptr<FPattern> received = std::static_pointer_cast<FPattern>(msg->getContent());
                    std::pair<int, std::shared_ptr<FPattern> > my_pair(received->getId() , received);
                    m_patterns.insert( my_pair );
                    std::cout << "M_PATTERNS SIZE IS NOW : " << m_patterns.size() << std::endl;
                    break;
                }
                case(TIMESTAMP):
                {
                    std::cout << "CORE >>> TIMESTAMP MESSAGE RECEIVED FROM PARSER" << std::endl;
                    m_parser_timestamps.push( msg );
                    break;
                }
                case(OCCURRENCE):
                {
                    std::cout << "CORE >>> OCCURRENCE MESSAGE RECEIVED FROM PARSER" << std::endl;
                    m_parser_occurrences.push( msg );
                    break;
                }
                default:

                break;
            }
        }    
    }
}



/*
 * MESSAGE HANDLER RENDER
 * THIS THREAD TAKE MESSAGES FROM THE RENDER AND CHECK WHAT IT MUST WITH THEM
 */
void FCore::thr_messages_handler_render(){
    std::cout << "in thr_messages_handler_render" << std::endl;
    while(1){
        std::shared_ptr<FMessages> msg = *(_m_pop_queue_render->wait_and_pop());
        if( msg.use_count() != 0 && msg != NULL){
            switch(msg->getHeader()){
                case(START):
                {
                	std::cout << "CORE >>> START MESSAGE RECEIVED FROM RENDER" << std::endl;
                    awake = false;
                break;
                }
                case(INITDONE):
                {
                	std::cout << "CORE >>> INITDONE MESSAGE RECEIVED FROM RENDER" << std::endl;
                    break;
                }
                case(CONTAINER):
                {
                	std::cout << "CORE >>> CONTAINER MESSAGE RECEIVED FROM RENDER" << std::endl;

                    break;
                }
                case(PATTERN):
                {
                	std::cout << "CORE >>> PATTERN MESSAGE RECEIVED FROM RENDER" << std::endl;
                    
                    std::shared_ptr<int> pattern_received = std::static_pointer_cast<int>(msg->getContent());
                    std::shared_ptr<FPattern> pattern_to_send = m_patterns[ *(pattern_received) ];
                    auto content_send = std::static_pointer_cast<void>( pattern_to_send );
                	FMessages msg_send(PATTERN, content_send);
                	_m_push_queue_render->push( std::make_shared<FMessages>(msg_send) );
                	std::cout << "CORE >>> PATTERN MESSAGE RETURNED FROM RENDER" << std::endl;
                    
                    break;
                }
                case(TIMESTAMP):
                {
                	std::cout << "CORE >>> TIMESTAMP MESSAGE RECEIVED FROM RENDER" << std::endl;
                    m_render_timestamps.push( msg );
                    break;
                }
                case(OCCURRENCE):
                {
                	std::cout << "CORE >>> OCCURRENCE MESSAGE RECEIVED FROM RENDER" << std::endl;
                    m_render_occurrences.push( msg );
                    break;
                }
                default:

                break;
            }
        }
    }   
}




void  FCore::thr_check_memory(){
    if(m_occurrences.size() > MAX_SIZE){
        !m_occurrences.erase();
    }
}

    
void FCore::thr_FCore(){
    
    std::cout << "start message_handler_parser_" << std::endl;
    std::thread message_handler_parser_( [this]{thr_messages_handler_parser();} );
    FThread_guard mhpp_g( message_handler_parser_ );

    std::cout << "start timestamps_manager_" << std::endl;
    std::thread timestamps_manager_( [this]{thr_timestamps_manager();} );
    FThread_guard tm_g(timestamps_manager_);

    std::cout << "start occurrences_manager_" << std::endl;
    std::thread occurrences_manager_( [this]{thr_occurrences_manager();} );
    FThread_guard om_g(occurrences_manager_);

    std::cout << "start message_handler_render_" << std::endl;
    std::thread message_handler_render_( [this]{thr_messages_handler_render();} );
    FThread_guard mhpr_g( message_handler_render_ );
/*
    while(awake){
            
    } 
   */ 
    std::cout << "AWAKE DONE" <<std::endl;

    std::cout << "start check_memory_" << std::endl;
    std::thread check_memory_( [this]{thr_check_memory();} );
    FThread_guard mem_g( check_memory_ );
}

/*
static std::vector<std::shared_ptr<FContainer> > view_containers(int a, int b){
    std::vector<std::shared_ptr<FContainer> > result;
    for(int i = a; i <= b; ++i){
        result.push_back( FCore::m_containers[i] );
    }
    return result;
}

static std::shared_ptr<FPattern>  view_patterns(int a){
    return FCore::m_patterns[a];
}
*/

void FCore::start(){
    std::cout << "start FCore" << std::endl;

    std::thread fCore_( [this]{thr_FCore();} );
    fCore_.detach();

    //FThread_guard fc_g( fCore_ );
}


float FCore::getContainerContent(int id, float t1){
    bool isContinue = false;
    for(auto it = m_containers.at(id)->getPatternList().begin(); it != m_containers.at(id)->getPatternList().end(); ++it ){
        if( it->tBegin >= t1 ){
            auto it_tmp = it;
            ++it_tmp;
            if(it->tEnd <= it_tmp->tBegin + 0.01 || it->tEnd >= it_tmp->tBegin - 0.01){
                isContinue = true;
            }else{
                isContinue = false;
            }

            if(!isContinue){
                return it->tEnd;
            }
        }
    }

    return m_containers.at(id)->getPatternList().end()->tEnd;
}

bool FCore::isContainerFull(int id, float t1, float t2){
    bool isContinue = false;
    for(auto it = m_containers.at(id)->getPatternList().begin(); it != m_containers.at(id)->getPatternList().end(); ++it ){
        if( it->tBegin >= t1 ){
            auto it_tmp = it;
            ++it_tmp;
            if(it->tEnd <= it_tmp->tBegin + 0.01 || it->tEnd >= it_tmp->tBegin - 0.01){
                isContinue = true;
            }else{
                isContinue = false;
            }

            if(isContinue && it->tEnd >t2 ){
                return true;
            }
        }

        if( it->tBegin > t1 && it->tEnd > t2 ){
            return false;
        }
    }

    return false;
}

bool FCore::contains_occurrence(int idPattern, int idOccurrence){
//m_occurrences[ received.first ]->contains( received.second ) 
	for(auto it = m_occurrences[idPattern]->begin(); it != m_occurrences[idPattern]->end(); ++it ){
		if( (*it)->getId() == idOccurrence){
			return true;
		}else if( (*it)->getId() > idOccurrence ){
			return false;
		}
	}
	return false;
}

std::shared_ptr<FOccurrence> FCore::find_occurrence(int idPattern, int idOccurrence){
	for(auto it = m_occurrences[idPattern]->begin(); it != m_occurrences[idPattern]->end(); ++it ){
		if( (*it)->getId() == idOccurrence){
			return (*it);
		}
	}	
	return NULL;
}